<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cute Gesture Trail</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');
        body {
            font-family: 'Poppins', sans-serif;
        }
        /* Custom styles for the loader */
        .loader {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto text-center">
        <h1 class="text-4xl md:text-5xl font-bold text-pink-500 mb-2">Cute Gesture Tracker</h1>
        <p class="text-lg md:text-xl text-gray-600 dark:text-gray-400 mb-6">Show a thumbs up, OK sign, or make a heart with two hands!</p>
        <button id="start-button" class="bg-pink-500 hover:bg-pink-600 text-white font-bold py-3 px-6 rounded-lg text-xl transition duration-300 shadow-lg">Start Camera</button>
    </div>

    <div id="loading-container" class="absolute inset-0 bg-black bg-opacity-50 flex-col items-center justify-center z-20 hidden">
        <div class="loader"></div>
        <p class="mt-4 text-white text-lg">Starting camera and loading models...</p>
    </div>

    <div id="video-container" class="relative w-full max-w-4xl aspect-video rounded-2xl shadow-2xl overflow-hidden bg-gray-800 hidden mt-4">
        <!-- The video element will be hidden but used as the source for the canvas -->
        <video id="webcam" class="hidden" autoplay playsinline></video>
        <!-- The canvas is where we'll draw the video, landmarks, and effects -->
        <canvas id="output-canvas" class="absolute top-0 left-0 w-full h-full"></canvas>
    </div>

    <!-- MediaPipe scripts -->
    <script type="module">
        import {
            HandLandmarker,
            FilesetResolver,
            DrawingUtils
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        // The old, separate import was causing the error and has been removed.
        
        // Define HAND_CONNECTIONS directly as a workaround for the module export error.
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
            [0, 5], [5, 6], [6, 7], [7, 8], // Index finger
            [0, 9], [9, 10], [10, 11], [11, 12], // Middle finger
            [0, 13], [13, 14], [14, 15], [15, 16], // Ring finger
            [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
            [5, 9], [9, 13], [13, 17] // Palm
        ];

        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output-canvas');
        const ctx = canvas.getContext('2d');
        const drawingUtils = new DrawingUtils(ctx); // Create an instance of DrawingUtils
        const loadingContainer = document.getElementById('loading-container');
        const startButton = document.getElementById('start-button');
        const videoContainer = document.getElementById('video-container');

        let handLandmarker;
        let runningMode = "VIDEO";
        
        // Trail storage for the index finger
        const trailPoints = [];

        // --- Gesture Detection Functions ---
        const isThumbsUp = (landmarks) => {
            const thumbTip = landmarks[4];
            const indexPip = landmarks[6]; // A good reference for the base of the fingers

            if (thumbTip.y >= indexPip.y) {
                return false;
            }
            const fingersFolded = 
                landmarks[8].y > landmarks[6].y &&
                landmarks[12].y > landmarks[10].y &&
                landmarks[16].y > landmarks[14].y &&
                landmarks[20].y > landmarks[18].y;
            return fingersFolded;
        };
        
        const isOkSign = (landmarks, h, w) => {
            const thumbTip = { x: landmarks[4].x * w, y: landmarks[4].y * h };
            const indexTip = { x: landmarks[8].x * w, y: landmarks[8].y * h };
            
            const distance = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
            const fingersExtended = 
                landmarks[12].y < landmarks[10].y &&
                landmarks[16].y < landmarks[14].y &&
                landmarks[20].y < landmarks[18].y;

            return distance < (w * 0.1) && fingersExtended;
        };

        const isHeartGesture = (hand1, hand2, h, w) => {
            const index1 = { x: hand1[8].x * w, y: hand1[8].y * h };
            const thumb1 = { x: hand1[4].x * w, y: hand1[4].y * h };
            const index2 = { x: hand2[8].x * w, y: hand2[8].y * h };
            const thumb2 = { x: hand2[4].x * w, y: hand2[4].y * h };

            const indexDist = Math.sqrt(Math.pow(index1.x - index2.x, 2) + Math.pow(index1.y - index2.y, 2));
            const thumbDist = Math.sqrt(Math.pow(thumb1.x - thumb2.x, 2) + Math.pow(thumb1.y - thumb2.y, 2));

            return indexDist < (w * 0.15) && thumbDist < (w * 0.2) && hand1[8].y < hand1[5].y && hand2[8].y < hand2[5].y;
        };

        // --- Helper: Draw Cute Glowing Text ---
        const drawCuteText = (text, pos, color) => {
            const { x, y } = pos;
            const scale = Math.min(canvas.width, canvas.height) / 300;
            ctx.font = `bold ${scale * 2}rem 'Poppins', sans-serif`;
            ctx.textAlign = 'center';
            ctx.shadowColor = 'white';
            ctx.shadowBlur = 15;
            ctx.fillStyle = color;
            ctx.fillText(text, x, y);
            ctx.shadowBlur = 0;
        };
        
        const createHandLandmarker = async () => {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: runningMode,
                numHands: 2
            });
            loadingContainer.style.display = 'none';
        };

        // --- Main Webcam and Prediction Loop ---
        const enableWebcam = () => {
             navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } })
                .then(stream => {
                    video.srcObject = stream;
                    videoContainer.style.display = 'block';
                    video.addEventListener('loadeddata', predictWebcam);
                })
                .catch(err => {
                    console.error("Error accessing webcam: ", err);
                    let errorMessage = "Could not access webcam. Please grant permission and refresh.";
                    if (err.name === "NotAllowedError") {
                        errorMessage = "Camera permission was denied. Please allow camera access in your browser settings and refresh the page.";
                    } else if (err.name === "NotFoundError") {
                        errorMessage = "No camera was found. Please ensure a camera is connected and enabled.";
                    }
                    loadingContainer.innerHTML = `<p class="text-red-500 text-lg p-4 text-center">${errorMessage}</p>`;
                    loadingContainer.style.display = 'flex';
                });
        };

        let lastVideoTime = -1;
        const predictWebcam = async () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            let startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime && handLandmarker) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, startTimeMs);

                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                ctx.restore();

                if (results.landmarks) {
                    const allHands = results.landmarks;

                    if (allHands.length > 0) {
                         const indexFingertip = allHands[0][8];
                         const x = indexFingertip.x * canvas.width;
                         const y = indexFingertip.y * canvas.height;
                         trailPoints.push({ x, y });
                         if (trailPoints.length > 30) {
                             trailPoints.shift();
                         }
                    }
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.shadowColor = '#0ff';
                    ctx.shadowBlur = 20;

                    for (let i = 1; i < trailPoints.length; i++) {
                        const alpha = i / trailPoints.length;
                        ctx.beginPath();
                        ctx.moveTo(trailPoints[i-1].x, trailPoints[i-1].y);
                        ctx.lineTo(trailPoints[i].x, trailPoints[i].y);
                        ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                        ctx.lineWidth = 10 * alpha;
                        ctx.stroke();
                    }
                    ctx.shadowBlur = 0;

                    for (const landmarks of allHands) {
                        // Use the drawingUtils instance to draw landmarks and connectors
                        drawingUtils.drawConnectors(landmarks, HAND_CONNECTIONS, { color: '#FFFFFF', lineWidth: 5 });
                        drawingUtils.drawLandmarks(landmarks, { color: '#FF00FF', lineWidth: 2, radius: 6 });

                        if (isThumbsUp(landmarks)) {
                            drawCuteText("âœ¨ Thumbs Up! âœ¨", { x: canvas.width / 2, y: canvas.height * 0.15 }, 'lime');
                        } else if (isOkSign(landmarks, canvas.height, canvas.width)) {
                            drawCuteText("ðŸ’– Okie Dokie! ðŸ’–", { x: canvas.width / 2, y: canvas.height * 0.25 }, '#ff69b4');
                        }
                    }

                    if (allHands.length === 2) {
                        if (isHeartGesture(allHands[0], allHands[1], canvas.height, canvas.width)) {
                            drawCuteText("â¤ï¸ Heart!! â¤ï¸", { x: canvas.width / 2, y: canvas.height * 0.35 }, '#ff0000');
                             drawCuteText("So Cute!! âœ¨", { x: canvas.width / 2, y: canvas.height * 0.45 }, '#ff1493');
                        }
                    }
                }
            }
            window.requestAnimationFrame(predictWebcam);
        };
        
        startButton.addEventListener('click', async () => {
            loadingContainer.style.display = 'flex';
            startButton.style.display = 'none';
            await createHandLandmarker();
            enableWebcam();
        });
    </script>
</body>
</html>

